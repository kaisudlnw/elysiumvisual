-- ============================================================================
-- ROUTER CLIENT HOOK
-- ============================================================================

-- Check if already hooked by another script
if not _G.PetSystem_RouterHooked then
    local routerUpvalue = debug.getupvalue(
        require(game.ReplicatedStorage.Fsys).load("RouterClient").init, 
        7
    )

    local routerIterator, routerState, routerKey = pairs(routerUpvalue)
    _G.PetSystem_RouterFunctions = {}

    while true do
        local value
        routerKey, value = routerIterator(routerState, routerKey)
        if routerKey == nil then break end
        value.Name = routerKey
        _G.PetSystem_RouterFunctions[routerKey] = value
    end
    
    _G.PetSystem_RouterHooked = true
else
    print("Router already hooked by another script, sharing hook...")
end

local routerFunctions = _G.PetSystem_RouterFunctions

-- ============================================================================
-- FSYS LOADER
-- ============================================================================

local Fsys = require(game:GetService("ReplicatedStorage"):WaitForChild("Fsys"))
local UIManager = Fsys.load("UIManager")
local inventory = Fsys.load("ClientData").get("inventory").toys

local toyIterator, toyState, toyKey = pairs(inventory)
local tradeLicense = nil

while true do
    local value
    toyKey, value = toyIterator(toyState, toyKey)
    if toyKey == nil then
        toyKey = tradeLicense
        break
    end
    if value.id == "trade_license" then
        break
    end
end

-- ============================================================================
-- TOOL API OVERRIDE
-- ============================================================================

if not _G.PetSystem_ToolAPIOverridden then
    local toolAPIOverrides = {
        ["ToolAPI/Equip"] = function(arg1, arg2, ...)
            if arg2 == toyKey then
                UIManager.set_app_visibility("TradeHistoryApp", true)
            end
            return routerFunctions["ToolAPI/Equip"](arg1, arg2, ...)
        end,
        
        ["ToolAPI/Unequip"] = function(arg1, arg2)
            if arg2 == toyKey then
                UIManager.set_app_visibility("TradeHistoryApp", false)
            end
            return routerFunctions["ToolAPI/Unequip"](arg1, arg2)
        end
    }

    debug.setupvalue(
        require(game.ReplicatedStorage.Fsys).load("RouterClient").init,
        7,
        setmetatable(toolAPIOverrides, {
            __index = routerFunctions,
            __newindex = function(self, key, value)
                if key == "ToolAPI/Equip" or key == "ToolAPI/Unequip" then
                    rawset(self, key, value)
                else
                    routerFunctions[key] = value
                end
            end
        })
    )
    
    _G.PetSystem_ToolAPIOverridden = true
end

-- ============================================================================
-- TRADE HISTORY APP MODIFICATIONS
-- ============================================================================

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UIManagerService = require(ReplicatedStorage:WaitForChild("Fsys")).load("UIManager")
local TradeHistoryApp = UIManagerService.apps.TradeHistoryApp
local TradeApp = UIManagerService.apps.TradeApp
local LocalPlayer = Players.LocalPlayer

-- Backup original functions (only once, globally)
if not _G.PetSystem_TradeBackups then
    _G.PetSystem_TradeBackups = {
        create_trade_frame = TradeHistoryApp._create_trade_frame,
        change_local_trade_state = TradeApp._change_local_trade_state,
        overwrite_local_trade_state = TradeApp._overwrite_local_trade_state
    }
end

if not _G.PetSystem_TradeStates then
    _G.PetSystem_TradeStates = {}
end

local tradeStates = _G.PetSystem_TradeStates

-- Override trade state change (only if not already overridden)
if not _G.PetSystem_TradeOverridden then
    function TradeApp._change_local_trade_state(self, changes, ...)
        local currentState = self:_get_local_trade_state()
        
        if currentState and currentState.trade_id then
            if currentState.sender ~= LocalPlayer or not changes.sender_offer then
                if currentState.recipient == LocalPlayer and changes.recipient_offer then
                    tradeStates[currentState.trade_id] = {
                        items = table.clone(changes.recipient_offer.items),
                        isSender = false
                    }
                end
            else
                tradeStates[currentState.trade_id] = {
                    items = table.clone(changes.sender_offer.items),
                    isSender = true
                }
            end
        end
        
        -- Track current items
        local tradeState = TradeApp.local_trade_state
        local offerKey = tradeState and (
            tradeState.sender == LocalPlayer and "sender_offer" or 
            (tradeState.recipient == LocalPlayer and "recipient_offer" or false)
        )
        
        if offerKey then
            local offer = changes[offerKey]
            if offer and offer.items then
                _G.PetSystem_CurrentItems = offer.items
            end
        end
        
        return _G.PetSystem_TradeBackups.change_local_trade_state(self, changes, ...)
    end

    -- Override trade state overwrite
    function TradeApp._overwrite_local_trade_state(self, newState, ...)
        if not newState and TradeApp._last_trade_id then
            tradeStates[TradeApp._last_trade_id] = nil
        end
        
        if newState then
            local playerOffer = newState.sender == LocalPlayer and newState.sender_offer
            
            if not playerOffer then
                if newState.recipient ~= LocalPlayer then
                    playerOffer = false
                else
                    playerOffer = newState.recipient_offer
                end
            end
            
            if playerOffer and _G.PetSystem_CurrentItems then
                playerOffer.items = _G.PetSystem_CurrentItems
            end
        else
            _G.PetSystem_CurrentItems = nil
        end
        
        return _G.PetSystem_TradeBackups.overwrite_local_trade_state(self, newState, ...)
    end

    -- Override trade frame creation
    function TradeHistoryApp._create_trade_frame(self, tradeData, ...)
        if not (tradeData.trade_id and tradeStates[tradeData.trade_id]) then
            return _G.PetSystem_TradeBackups.create_trade_frame(self, tradeData, ...)
        end
        
        local stateData = tradeStates[tradeData.trade_id]
        local modifiedData = table.clone(tradeData)
        
        if stateData.isSender then
            modifiedData.sender_items = table.clone(stateData.items)
        else
            modifiedData.recipient_items = table.clone(stateData.items)
        end
        
        return _G.PetSystem_TradeBackups.create_trade_frame(self, modifiedData, ...)
    end
    
    _G.PetSystem_TradeOverridden = true
end

-- ============================================================================
-- PET SPAWNER SYSTEM
-- ============================================================================

local LocalPlayer = game:GetService("Players").LocalPlayer

local petOptions = {
    F = false,  -- Flyable
    R = false,  -- Rideable
    N = false,  -- Neon
    M = false   -- Mega Neon
}

task.spawn(function()
    local fsysLoad = require(game.ReplicatedStorage:WaitForChild("Fsys")).load
    
    set_thread_identity(2)
    local ClientData = fsysLoad("ClientData")
    local KindDB = fsysLoad("KindDB")
    local RouterClient = fsysLoad("RouterClient")
    local DownloadClient = fsysLoad("DownloadClient")
    local AnimationManager = fsysLoad("AnimationManager")
    local PetRigs = fsysLoad("new:PetRigs")
    set_thread_identity(8)
    
    -- Use shared spawned pets table
    if not _G.PetSystem_SpawnedPets then
        _G.PetSystem_SpawnedPets = {}
    end
    
    local downloadedModels = {}
    local spawnedPets = _G.PetSystem_SpawnedPets
    local currentEquippedPet = nil
    local currentRidingPet = nil
    local ridingAnimation = nil
    
    -- ========================================================================
    -- UTILITY FUNCTIONS
    -- ========================================================================
    
    local function predictClientData(dataKey, updateFunc)
        local data = ClientData.get(dataKey)
        local clonedData = table.clone(data)
        ClientData.predict(dataKey, updateFunc(clonedData))
    end
    
    local function generateGUID()
        return game:GetService("HttpService"):GenerateGUID(false)
    end
    
    local function downloadPetModel(kindId)
        if downloadedModels[kindId] then
            return downloadedModels[kindId]
        end
        
        local model = DownloadClient.promise_download_copy("Pets", kindId):expect()
        downloadedModels[kindId] = model
        return model
    end
    
    local function createPet(petId, properties)
        local uniqueId = generateGUID()
        local petKind = KindDB[petId]
        
        if not petKind then
            warn("Pet ID not found: " .. petId)
            return nil
        end
        
        set_thread_identity(2)
        local petData = {
            unique = uniqueId,
            category = "pets",
            id = petId,
            kind = petKind.kind,
            newness_order = math.random(1, 900000),
            properties = properties or {}
        }
        ClientData.get("inventory").pets[uniqueId] = petData
        set_thread_identity(8)
        
        spawnedPets[uniqueId] = {
            data = petData,
            model = nil
        }
        
        return petData
    end
    
    local function createToy(toyId)
        local uniqueId = generateGUID()
        local toyKind = KindDB[toyId]
        
        if not toyKind then
            warn("Toy ID not found: " .. toyId)
            return nil
        end
        
        set_thread_identity(2)
        local toyData = {
            unique = uniqueId,
            category = "toys",
            id = toyId,
            kind = toyKind.kind,
            newness_order = math.random(1, 900000),
            properties = {}
        }
        ClientData.get("inventory").toys[uniqueId] = toyData
        set_thread_identity(8)
        
        return toyData
    end
    
    local function applyNeonParts(petModel, petData)
        local petModelChild = petModel:FindFirstChild("PetModel")
        if petModelChild then
            for partName, partData in pairs(petData.neon_parts) do
                local geoPart = PetRigs.get(petModelChild).get_geo_part(petModelChild, partName)
                geoPart.Material = partData.Material
                geoPart.Color = partData.Color
            end
        end
    end
    
    local function addPetCharWrapper(wrapperData)
        predictClientData("pet_char_wrappers", function(wrappers)
            wrapperData.unique = #wrappers + 1
            wrapperData.index = #wrappers + 1
            wrappers[#wrappers + 1] = wrapperData
            return wrappers
        end)
    end
    
    local function addPetStateManager(managerData)
        predictClientData("pet_state_managers", function(managers)
            managers[#managers + 1] = managerData
            return managers
        end)
    end
    
    local function findInTable(tbl, predicate)
        for index, value in pairs(tbl) do
            if predicate(value, index) then
                return index
            end
        end
        return nil
    end
    
    local function removePetCharWrapper(petUniqueId)
        predictClientData("pet_char_wrappers", function(wrappers)
            local index = findInTable(wrappers, function(wrapper)
                return wrapper.pet_unique == petUniqueId
            end)
            
            if not index then return wrappers end
            
            table.remove(wrappers, index)
            
            for i, wrapper in pairs(wrappers) do
                wrapper.unique = i
                wrapper.index = i
            end
            
            return wrappers
        end)
    end
    
    local function clearPetStates(petUniqueId)
        local petInfo = spawnedPets[petUniqueId]
        if not petInfo then return end
        if not petInfo.model then return end
        
        predictClientData("pet_state_managers", function(managers)
            local index = findInTable(managers, function(manager)
                return manager.char == petInfo.model
            end)
            
            if not index then return managers end
            
            local newManagers = table.clone(managers)
            newManagers[index] = table.clone(newManagers[index])
            newManagers[index].states = {}
            return newManagers
        end)
    end
    
    local function setPetState(petUniqueId, stateId)
        local petInfo = spawnedPets[petUniqueId]
        if not petInfo then return end
        if not petInfo.model then return end
        
        predictClientData("pet_state_managers", function(managers)
            local index = findInTable(managers, function(manager)
                return manager.char == petInfo.model
            end)
            
            if not index then return managers end
            
            local newManagers = table.clone(managers)
            newManagers[index] = table.clone(newManagers[index])
            newManagers[index].states = {{id = stateId}}
            return newManagers
        end)
    end
    
    local function attachRideConstraint(petModel)
        local character = game.Players.LocalPlayer.Character
        if not character then return false end
        if not character.PrimaryPart then return false end
        
        local ridePosition = petModel:FindFirstChild("RidePosition", true)
        if not ridePosition then return false end
        
        local attachment = Instance.new("Attachment")
        attachment.Parent = ridePosition
        attachment.Position = Vector3.new(0, 1.237, 0)
        attachment.Name = "SourceAttachment"
        
        local constraint = Instance.new("RigidConstraint")
        constraint.Name = "StateConnection"
        constraint.Attachment0 = attachment
        constraint.Attachment1 = character.PrimaryPart.RootAttachment
        constraint.Parent = character
        
        return true
    end
    
    local function clearPlayerStates()
        predictClientData("state_manager", function(manager)
            local newManager = table.clone(manager)
            newManager.states = {}
            newManager.is_sitting = false
            return newManager
        end)
    end
    
    local function setPlayerState(stateId)
        predictClientData("state_manager", function(manager)
            local newManager = table.clone(manager)
            newManager.states = {{id = stateId}}
            newManager.is_sitting = true
            return newManager
        end)
    end
    
    local function removePetStateManager(petUniqueId)
        local petInfo = spawnedPets[petUniqueId]
        if not petInfo then return end
        if not petInfo.model then return end
        
        predictClientData("pet_state_managers", function(managers)
            local index = findInTable(managers, function(manager)
                return manager.char == petInfo.model
            end)
            
            if not index then return managers end
            
            table.remove(managers, index)
            return managers
        end)
    end
    
    local function exitRiding(petUniqueId)
        local petInfo = spawnedPets[petUniqueId]
        if not petInfo then return end
        if not petInfo.model then return end
        
        if ridingAnimation then
            ridingAnimation:Stop()
            ridingAnimation:Destroy()
        end
        
        local attachment = petInfo.model:FindFirstChild("SourceAttachment", true)
        if attachment then
            attachment:Destroy()
        end
        
        if game.Players.LocalPlayer.Character then
            for _, descendant in pairs(game.Players.LocalPlayer.Character:GetDescendants()) do
                if descendant:IsA("BasePart") and descendant:GetAttribute("HaveMass") then
                    descendant.Massless = false
                end
            end
        end
        
        clearPetStates(petUniqueId)
        clearPlayerStates()
        petInfo.model:ScaleTo(1)
        currentRidingPet = nil
    end
    
    local function startRiding(petUniqueId, playerState, petState)
        local petInfo = spawnedPets[petUniqueId]
        if not petInfo then return end
        if not petInfo.model then return end
        
        local player = game.Players.LocalPlayer
        if not player.Character then return end
        if not player.Character.PrimaryPart then return end
        
        currentRidingPet = petUniqueId
        setPetState(petUniqueId, petState)
        setPlayerState(playerState)
        petInfo.model:ScaleTo(2)
        attachRideConstraint(petInfo.model)
        
        ridingAnimation = player.Character.Humanoid.Animator:LoadAnimation(
            AnimationManager.get_track("PlayerRidingPet")
        )
        player.Character.Humanoid.Sit = true
        
        for _, descendant in pairs(player.Character:GetDescendants()) do
            if descendant:IsA("BasePart") and descendant.Massless == false then
                descendant.Massless = true
                descendant:SetAttribute("HaveMass", true)
            end
        end
        
        ridingAnimation:Play()
    end
    
    local function flyPet(petUniqueId)
        startRiding(petUniqueId, "PlayerFlyingPet", "PetBeingFlown")
    end
    
    local function ridePet(petUniqueId)
        startRiding(petUniqueId, "PlayerRidingPet", "PetBeingRidden")
    end
    
    local function unequipPet(petData)
        local petInfo = spawnedPets[petData.unique]
        if not petInfo then return end
        if not petInfo.model then return end
        
        exitRiding(petData.unique)
        removePetCharWrapper(petData.unique)
        removePetStateManager(petData.unique)
        petInfo.model:Destroy()
        petInfo.model = nil
        currentEquippedPet = nil
    end
    
    local function equipPet(petData)
        if petData.category ~= "pets" then
            return
        end
        
        if currentEquippedPet then
            unequipPet(currentEquippedPet)
        end
        
        local petModel = downloadPetModel(petData.kind):Clone()
        petModel.Parent = workspace
        spawnedPets[petData.unique].model = petModel
        
        if petData.properties.neon or petData.properties.mega_neon then
            applyNeonParts(petModel, KindDB[petData.id])
        end
        
        currentEquippedPet = petData
        
        addPetCharWrapper({
            char = petModel,
            mega_neon = petData.properties.mega_neon,
            neon = petData.properties.neon,
            player = game.Players.LocalPlayer,
            entity_controller = game.Players.LocalPlayer,
            controller = game.Players.LocalPlayer,
            rp_name = petData.properties.rp_name or "",
            pet_trick_level = petData.properties.pet_trick_level,
            pet_unique = petData.unique,
            pet_id = petData.id,
            location = {
                full_destination_id = "housing",
                destination_id = "housing",
                house_owner = game.Players.LocalPlayer
            },
            pet_progression = {
                age = math.random(1, 900000),
                percentage = math.random(0.01, 0.99)
            },
            are_colors_sealed = false,
            is_pet = true
        })
        
        addPetStateManager({
            char = petModel,
            player = game.Players.LocalPlayer,
            store_key = "pet_state_managers",
            is_sitting = false,
            chars_connected_to_me = {},
            states = {}
        })
    end
    
    -- ========================================================================
    -- ROUTER CLIENT OVERRIDES
    -- ========================================================================
    
    local originalRouterGet = _G.PetSystem_OriginalRouterGet or RouterClient.get
    if not _G.PetSystem_OriginalRouterGet then
        _G.PetSystem_OriginalRouterGet = originalRouterGet
    end
    
    local function createFakeRemote(handler)
        return {
            InvokeServer = function(_, ...)
                return handler(...)
            end
        }
    end
    
    local equipRemote = createFakeRemote(function(uniqueId, slot)
        local petInfo = spawnedPets[uniqueId]
        if not petInfo then
            return originalRouterGet("ToolAPI/Equip"):InvokeServer(uniqueId, slot)
        end
        equipPet(petInfo.data)
        return true, {action = "equip", is_server = true}
    end)
    
    local unequipRemote = createFakeRemote(function(uniqueId)
        local petInfo = spawnedPets[uniqueId]
        if not petInfo then
            return originalRouterGet("ToolAPI/Unequip"):InvokeServer(uniqueId)
        end
        unequipPet(petInfo.data)
        return true, {action = "unequip", is_server = true}
    end)
    
    local ridePetRemote = createFakeRemote(function(data)
        ridePet(data.pet_unique)
    end)
    
    local flyPetRemote = createFakeRemote(function(data)
        flyPet(data.pet_unique)
    end)
    
    local exitSeatRemote = createFakeRemote(function()
        exitRiding(currentRidingPet)
    end)
    
    local exitSeatEvent = (function(handler)
        return {
            FireServer = function(_, ...)
                return handler(...)
            end
        }
    end)(function()
        exitRiding(currentRidingPet)
    end)
    
    function RouterClient.get(key)
        if key == "ToolAPI/Equip" then
            return equipRemote
        elseif key == "ToolAPI/Unequip" then
            return unequipRemote
        elseif key == "AdoptAPI/RidePet" then
            return ridePetRemote
        elseif key == "AdoptAPI/FlyPet" then
            return flyPetRemote
        elseif key == "AdoptAPI/ExitSeatStatesYield" then
            return exitSeatRemote
        elseif key == "AdoptAPI/ExitSeatStates" then
            return exitSeatEvent
        else
            return originalRouterGet(key)
        end
    end
    
    -- Unequip all existing pets
    for _, wrapper in pairs(ClientData.get("pet_char_wrappers")) do
        originalRouterGet("ToolAPI/Unequip"):InvokeServer(wrapper.pet_unique)
    end
    
    -- ========================================================================
    -- HELPER FUNCTIONS
    -- ========================================================================
    
    local InventoryDB = require(game.ReplicatedStorage.Fsys).load("InventoryDB")
    
    function GetPetByName(name)
        for _, pet in pairs(InventoryDB.pets) do
            if pet.name:lower() == name:lower() then
                return pet.id
            end
        end
        return false
    end
    
    function GetToyByName(name)
        for _, toy in pairs(InventoryDB.toys) do
            if toy.name:lower() == name:lower() then
                return toy.id
            end
        end
        return false
    end
    
    -- ========================================================================
    -- GLOBAL FUNCTIONS FOR GUI TO USE
    -- ========================================================================
    
    _G.PetSpawner = {
        Options = petOptions,
        SpawnPet = function(petName)
            local petId = GetPetByName(petName)
            if not petId then
                return false, "Pet not found: " .. petName
            end
            
            if petOptions.M then
                createPet(petId, {
                    pet_trick_level = math.random(1, 5),
                    mega_neon = true,
                    rideable = petOptions.R,
                    flyable = petOptions.F,
                    age = math.random(1, 900000),
                    ailments_completed = 0,
                    rp_name = ""
                })
            elseif petOptions.N then
                createPet(petId, {
                    pet_trick_level = math.random(0, 5),
                    neon = true,
                    rideable = petOptions.R,
                    flyable = petOptions.F,
                    age = math.random(1, 900000),
                    ailments_completed = 0,
                    rp_name = ""
                })
            else
                createPet(petId, {
                    pet_trick_level = math.random(1, 5),
                    neon = false,
                    mega_neon = false,
                    rideable = petOptions.R,
                    flyable = petOptions.F,
                    age = math.random(1, 900000),
                    ailments_completed = 0,
                    rp_name = ""
                })
            end
            
            return true, petName .. " has been spawned!"
        end,
        SpawnToy = function(toyName)
            local toyId = GetToyByName(toyName)
            if not toyId then
                return false, "Toy not found: " .. toyName
            end
            
            createToy(toyId)
            return true, toyName .. " has been spawned!"
        end,
        SpawnHighTier = function()
            local highTierPets = {
                "Shadow Dragon", "Bat Dragon", "Frost Dragon", "Giraffe", "Owl",
                "Parrot", "Crow", "Evil Unicorn", "Arctic Reindeer", "Hedgehog",
                "Dalmatian", "Turtle", "Kangaroo", "Lion", "Elephant", "Rhino",
                "Chocolate Chip Bat Dragon", "Cow", "Blazing Lion", "African Wild Dog",
                "Flamingo", "Diamond Butterfly", "Mini Pig", "Caterpillar", "Albino Monkey",
                "Candyfloss Chick", "Pelican", "Blue Dog", "Pink Cat", "Haetae",
                "Peppermint Penguin", "Winged Tiger", "Sugar Glider", "Shark Puppy",
                "Goat", "Sheeeeep", "Lion Cub", "Nessie", "Flamingo", "Frostbite Bear",
                "Balloon Unicorn", "Honey Badger", "Hot Doggo", "Crocodile", "Hare",
                "Ram", "Yeti", "Meetkat", "Jellyfish", "Happy Clown", "Orchid Butterfly",
                "Many Mackerel", "Strawberry Shortcake Bat Dragon", "Zombie Buffalo", "Fairy Bat Dragon"
            }
            
            local spawnCount = 0
            for _, petName in ipairs(highTierPets) do
                local petId = GetPetByName(petName)
                if petId then
                    if petOptions.M then
                        createPet(petId, {
                            pet_trick_level = math.random(1, 5),
                            mega_neon = true,
                            rideable = petOptions.R,
                            flyable = petOptions.F,
                            age = math.random(1, 900000),
                            ailments_completed = 0,
                            rp_name = ""
                        })
                    elseif petOptions.N then
                        createPet(petId, {
                            pet_trick_level = math.random(0, 5),
                            neon = true,
                            rideable = petOptions.R,
                            flyable = petOptions.F,
                            age = math.random(1, 900000),
                            ailments_completed = 0,
                            rp_name = ""
                        })
                    else
                        createPet(petId, {
                            pet_trick_level = math.random(1, 5),
                            neon = false,
                            mega_neon = false,
                            rideable = petOptions.R,
                            flyable = petOptions.F,
                            age = math.random(1, 900000),
                            ailments_completed = 0,
                            rp_name = ""
                        })
                    end
                    spawnCount = spawnCount + 1
                end
            end
            
            if spawnCount > 0 then
                return true, "Spawned " .. spawnCount .. " high tier pets!"
            else
                return false, "Failed to spawn high tier pets!"
            end
        end,
        Load = function()
            -- Load Rayfield Library
            local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()
            
            -- Create Window
            local Window = Rayfield:CreateWindow({
                Name = "Elysium Hub (Adopt Me)",
                Icon = "package",
                LoadingTitle = "Elysium Hub Loading",
                LoadingSubtitle = "by saaayden",
                ShowText = "Pet Spawner",
                Theme = "Default",
                
                ToggleUIKeybind = "K",
                
                DisableRayfieldPrompts = false,
                DisableBuildWarnings = false,
                
                ConfigurationSaving = {
                    Enabled = true,
                    FolderName = nil,
                    FileName = "PetSpawner"
                },
                
                Discord = {
                    Enabled = true,
                    Invite = "YXFY4p8jqm",
                    RememberJoins = false
                },
                
                KeySystem = false,
                KeySettings = {
                    Title = "Untitled",
                    Subtitle = "Key System",
                    Note = "No method of obtaining the key is provided",
                    FileName = "Key",
                    SaveKey = true,
                    GrabKeyFromSite = false,
                    Key = {"Hello"}
                }
            })
            
            -- Create Tabs
            local PetsTab = Window:CreateTab("Pets", "dog")
            local ToysTab = Window:CreateTab("Toys", "box")
            
            -- ================================================================
            -- PETS TAB
            -- ================================================================
            
            -- Pet Options Section
            local OptionsSection = PetsTab:CreateSection("Pet Options")
            
            local FlyToggle = PetsTab:CreateToggle({
                Name = "Flyable (F)",
                CurrentValue = false,
                Flag = "FlyToggle",
                Callback = function(Value)
                    petOptions.F = Value
                end,
            })
            
            local RideToggle = PetsTab:CreateToggle({
                Name = "Rideable (R)",
                CurrentValue = false,
                Flag = "RideToggle",
                Callback = function(Value)
                    petOptions.R = Value
                end,
            })
            
            local NeonToggle = PetsTab:CreateToggle({
                Name = "Neon (N)",
                CurrentValue = false,
                Flag = "NeonToggle",
                Callback = function(Value)
                    if Value and petOptions.M then
                        petOptions.M = false
                        MegaNeonToggle:Set(false)
                    end
                    petOptions.N = Value
                end,
            })
            
            local MegaNeonToggle = PetsTab:CreateToggle({
                Name = "Mega Neon (M)",
                CurrentValue = false,
                Flag = "MegaNeonToggle",
                Callback = function(Value)
                    if Value and petOptions.N then
                        petOptions.N = false
                        NeonToggle:Set(false)
                    end
                    petOptions.M = Value
                end,
            })
            
            -- Pet Spawning Section
            local SpawnSection = PetsTab:CreateSection("Spawn Pets")
            
            local PetInput = PetsTab:CreateInput({
                Name = "Pet Name",
                CurrentValue = "",
                PlaceholderText = "Enter Pet Name",
                RemoveTextAfterFocusLost = false,
                Flag = "PetInput",
                Callback = function(Text)
                    -- Text is stored for spawn button
                end,
            })
            
            local SpawnPetButton = PetsTab:CreateButton({
                Name = "Spawn Pet",
                Callback = function()
                    local petName = PetInput.CurrentValue
                    if petName == "" then
                        Rayfield:Notify({
                            Title = "Error",
                            Content = "Please enter a pet name!",
                            Duration = 3,
                            Image = "alert-circle",
                        })
                        return
                    end
                    
                    local success, message = _G.PetSpawner.SpawnPet(petName)
                    if success then
                        Rayfield:Notify({
                            Title = "Success!",
                            Content = message,
                            Duration = 5,
                            Image = "check-circle",
                        })
                    else
                        Rayfield:Notify({
                            Title = "Error",
                            Content = message,
                            Duration = 3,
                            Image = "alert-circle",
                        })
                    end
                end,
            })
            
            local SpawnHighTierButton = PetsTab:CreateButton({
                Name = "Spawn All High Tier Pets",
                Callback = function()
                    local success, message = _G.PetSpawner.SpawnHighTier()
                    if success then
                        Rayfield:Notify({
                            Title = "Success!",
                            Content = message,
                            Duration = 5,
                            Image = "check-circle",
                        })
                    else
                        Rayfield:Notify({
                            Title = "Error",
                            Content = message,
                            Duration = 3,
                            Image = "alert-circle",
                        })
                    end
                end,
            })
            
            -- Info Section
            local InfoSection = PetsTab:CreateSection("Information")
            
            local InfoParagraph = PetsTab:CreateParagraph({
                Title = "How to Use",
                Content = "1. Toggle pet options (Fly, Ride, Neon, Mega Neon)\n2. Enter a pet name or use the High Tier button\n3. Check your inventory for spawned pets!"
            })
            
            -- ================================================================
            -- TOYS TAB
            -- ================================================================
            
            local ToySpawnSection = ToysTab:CreateSection("Spawn Toys")
            
            local ToyInput = ToysTab:CreateInput({
                Name = "Toy Name",
                CurrentValue = "",
                PlaceholderText = "Enter Toy Name",
                RemoveTextAfterFocusLost = false,
                Flag = "ToyInput",
                Callback = function(Text)
                    -- Text is stored for spawn button
                end,
            })
            
            local SpawnToyButton = ToysTab:CreateButton({
                Name = "Spawn Toy",
                Callback = function()
                    local toyName = ToyInput.CurrentValue
                    if toyName == "" then
                        Rayfield:Notify({
                            Title = "Error",
                            Content = "Please enter a toy name!",
                            Duration = 3,
                            Image = "alert-circle",
                        })
                        return
                    end
                    
                    local success, message = _G.PetSpawner.SpawnToy(toyName)
                    if success then
                        Rayfield:Notify({
                            Title = "Success!",
                            Content = message,
                            Duration = 5,
                            Image = "check-circle",
                        })
                    else
                        Rayfield:Notify({
                            Title = "Error",
                            Content = message,
                            Duration = 3,
                            Image = "alert-circle",
                        })
                    end
                end,
            })
            
            local ToyInfoSection = ToysTab:CreateSection("Information")
            
            local ToyInfoParagraph = ToysTab:CreateParagraph({
                Title = "How to Use",
                Content = "1. Enter the name of a toy\n2. Click Spawn Toy\n3. Check your inventory for the toy!"
            })
            
            print("Pet Spawner GUI loaded successfully!")
        end
    }
    
    print("Pet Spawner loaded! Use _G.PetSpawner.Load() to open GUI.")
end)

_G.PetSpawner.Load()
